#+PROPERTY: header-args:emacs-lisp :tangle yes
* Basic information
#+begin_src emacs-lisp
(doom/set-frame-opacity 65)
(setq user-mail-address "david.jelenc@fri.uni-lj.si"
      user-full-name "David Jelenc")
#+end_src
* Look & Feel
** Fonts
Nice looking fonts, requires =nerdfonts=
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "CaskaydiaMono Nerd Font" :size 23 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "CaskaydiaMono Nerd Font" :size 21))
#+end_src
** Background
Set background transaprency
#+begin_src emacs-lisp
;; 0.0 = fully transparent, 1.0 = fully opaque
(defvar dj/alpha-bg 0.6)

(defun dj/apply-opacity (&optional frame)
  (let ((f (or frame (selected-frame))))
    (set-frame-parameter f 'alpha-background dj/alpha-bg)))

(dj/apply-opacity)
(add-to-list 'default-frame-alist `(alpha-background . ,dj/alpha-bg))
(add-hook 'after-make-frame-functions #'dj/apply-opacity)
#+end_src

** Theme
#+begin_src emacs-lisp
(setq doom-theme 'doom-gruvbox)
#+end_src

** Line numbers
#+begin_src emacs-lisp
(setq display-line-numbers-type 'visual)
#+end_src

Navigation: =j= and =k= work across wrapped lines, but commands work across whole lines
#+begin_src emacs-lisp
(map! :nv "j" #'evil-next-visual-line
      :nv "k" #'evil-previous-visual-line)
#+end_src

** Autorevert buffers
Update buffers when changed by other programs
#+begin_src emacs-lisp
(global-auto-revert-mode)
#+end_src
* Better navigation
** Fast search of ORG headings
Ripgrep over ORG files, and by default, only over Level 1 headings
#+begin_src emacs-lisp
;; Tell the compiler this is a special var coming from Consult.
(defvar consult-ripgrep-args)

(defun dj/consult-project-org-level1 ()
  "Search level-1 Org headings in the current project. C-u → include hidden/ignored."
  (interactive)
  (declare (special consult-ripgrep-args))
  (let* ((root (project-root (project-current t)))
         (consult-ripgrep-args
          (concat
           "rg --null --line-buffered --color=never --max-columns=1000 "
           "--path-separator / --line-number --smart-case --no-heading "
           "-g *.org")))
    ;; Initial query for level-2 headings:
    (consult-ripgrep root "^\\*[\*]?\\s[^*] ")))

(map! :desc "Go to any org headline (L1 only)"
      :leader "n SPC" #'dj/consult-project-org-level1)
#+end_src
** Basic shortcuts
#+begin_src emacs-lisp
(setq buffer-save-without-query t)
(map!
 :desc "Save all opened buffers" :leader "f S" (cmd! (save-some-buffers t))
 :desc "Switch buffer" :leader "b b" 'switch-to-buffer
 :desc "Next buffer" :leader "j" 'next-buffer
 :desc "Prev buffer" :leader "k" 'previous-buffer
 )
#+end_src
** Mark ring for prefix + C-o/C-i
Let C-o / C-i follow Evil's jumplist as usual, but if called with a prefix argument, use Org's mark ring.
#+begin_src emacs-lisp
;; - No prefix  -> normal Evil/evil-collection PDF jump
;; - With prefix -> use Org's mark ring (back to where you followed the link)
;; - And silence the stray "(4)" error and keep the behavior:
(defun dj/around-ec-pdf-jump (orig-fn &optional count)
  "Prefix -> `org-mark-ring-goto`. Else call ORIG-FN with COUNT=1.
Silences `wrong-type-argument` errors emitted by evil-collection when a prefix leaks."
  (condition-case _err
      (if current-prefix-arg
          (org-mark-ring-goto)
        (let ((current-prefix-arg nil))
          (funcall orig-fn (or count 1))))
    (wrong-type-argument
     ;; If some layer still received the raw prefix and complained, just redo cleanly:
     (let ((current-prefix-arg nil))
       (funcall orig-fn 1)))))

(with-eval-after-load 'evil-collection-pdf
  (advice-remove 'evil-collection-pdf-jump-backward #'dj/around-ec-pdf-jump)
  (advice-remove 'evil-collection-pdf-jump-forward  #'dj/around-ec-pdf-jump)
  (advice-add 'evil-collection-pdf-jump-backward :around #'dj/around-ec-pdf-jump)
  (advice-add 'evil-collection-pdf-jump-forward  :around #'dj/around-ec-pdf-jump))
#+end_src
* Org
#+begin_src emacs-lisp
(after! org
  ; (require 'org-mu4e) ;; required to have working links to mail
  (require 'oc)
  (require 'oc-csl)
  (require 'org-checklist) ;; required for automatic deselection of checkboxes for recurrent tasks
  (add-hook 'org-checkbox-statistics-hook 'dj/org-checkbox-todo)  ;; toggle task state when checkboxes are ticked
  (add-hook 'org-after-todo-statistics-hook 'dj/org-summary-todo) ;; toggle task state when subtask states are changed

  (setq org_notes "~/nextcloud/org/"
        org-attach-id-dir "org-attachments"
        org-id-link-to-org-use-id 'create-if-interactive
        org-agenda-files '("~/nextcloud/org/")
        org-directory org_notes
        org-default-notes-file (concat org_notes "/refile.org")
        org-startup-folded t
        evil-want-Y-yank-to-eol nil
        org-log-into-drawer t
        org-hierarchical-todo-statistics nil
        vc-follow-symlinks t

        org-refile-targets '(("~/nextcloud/org/active.org" :maxlevel . 1)
                             ("~/nextcloud/org/inactive.org" :maxlevel . 1)
                             ("~/nextcloud/org/toread.org" :maxlevel . 1)
                             ("~/nextcloud/org/someday.org" :maxlevel . 2)
                             ("~/nextcloud/org/reka.org" :maxlevel . 2)
                             ("~/nextcloud/org/zasebno.org" :maxlevel . 2)
                             ("~/nextcloud/org/tickler.org" :maxlevel . 1))

        org-capture-templates '(("n" "Todo" entry (file "refile.org") "* TODO %i%?")
                                ("j" "Linked Todo" entry (file "refile.org") "* TODO %? %a\n\n")
                                ("s" "Slipbox" entry  (file "../roam/inbox.org") "* %?\n")
                                ("p" "Protocol" entry (file "refile.org")
                                 "* TODO [[%:link][%:description]]\n%U\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?" :immediate-finish t)
                                ("L" "Protocol Link" entry (file "refile.org")
                                 "* TODO [[%:link][%:description]]\n%U\n\n" :immediate-finish t))

        org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELLED(c@/!)"))
        org-todo-keyword-faces '(("TODO" . "SlateGray")
                                 ("WAITING" . "Firebrick")
                                 ("DONE" . "ForestGreen")
                                 ("CANCELLED" .  "SlateBlue"))
        )
  (add-hook! 'org-capture-after-finalize-hook (org-element-cache-reset t))
  (defadvice! dan/+org--restart-mode-h-careful-restart (fn &rest args)
    :around #'+org--restart-mode-h
    (let ((old-org-capture-current-plist (and (bound-and-true-p org-capture-mode)
                                              (bound-and-true-p org-capture-current-plist))))
      (apply fn args)
      (when old-org-capture-current-plist
        (setq-local org-capture-current-plist old-org-capture-current-plist)
        (org-capture-mode +1))))
  )

(defun org-html--format-image (source attributes info)
  (format "<img src=\"data:image/%s;base64,%s\"%s />"
          (or (file-name-extension source) "")
          (base64-encode-string
           (with-temp-buffer
             (insert-file-contents-literally source)
             (buffer-string)))
          (file-name-nondirectory source)))
(defun dj/org-checkbox-todo()
  "Switch header todo state:
- to DONE when all checkboxes are checked;
- to NEXT otherwise."
  (let ((todo-state (org-get-todo-state)) beg end)
    (unless (not todo-state)
      (save-excursion
        (org-back-to-heading t)
        (setq beg (point))
        (end-of-line)
        (setq end (point))
        (goto-char beg)
        (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
            (if (match-end 1)
                (if (equal (match-string 1) "100%")
                    (unless (string-equal todo-state "DONE")
                      (org-todo 'done))
                  (when (string-equal todo-state "DONE")
                    (org-todo "NEXT"))) ;; default to NEXT when unchecking
              (if (and (> (match-end 2) (match-beginning 2))
                       (equal (match-string 2) (match-string 3)))
                  (unless (string-equal todo-state "DONE")
                    (org-todo 'done))
                (when (string-equal todo-state "DONE")
                  (org-todo "NEXT"))))))))) ;; default to NEXT when unchecking
(defun dj/org-summary-todo (n-done n-not-done)
  "Switch header todo state (if it has one):
- to DONE when all subentries are set to DONE;
- leave it unchanged otherwise."
  (if (org-entry-is-todo-p)
      (let ((todo-state (org-get-todo-state)))
        (org-todo (if (= n-not-done 0) "DONE" todo-state)))))
#+end_src
** Force deterministic generated anchor links
#+begin_src emacs-lisp
(after! org
  (defun org-export-deterministic-reference (references)
    (let ((new 0))
      (while (rassq new references) (setq new (+ new 1)))
      new))
  (advice-add #'org-export-new-reference :override #'org-export-deterministic-reference))
#+end_src
* Projectile
#+begin_src emacs-lisp
(after! projectile
  (add-to-list 'projectile-globally-ignored-directories "*org-attachments"))
#+end_src
* Mu4e
#+begin_src emacs-lisp
(after! mu4e
  (require 'mu4e-compat)
  (mu4e-compat-define-aliases-backwards)
  (require 'mu4e-org)
  (add-to-list 'mm-discouraged-alternatives "text/html")
  (add-to-list 'mm-discouraged-alternatives "text/richtext")
  (setq sendmail-program (executable-find "msmtp")
        ; https://github.com/djcb/mu/issues/2662#issuecomment-2147205731
        rfc2047-quote-decoded-words-containing-tspecials t
        mu4e-org-link-query-in-headers-mode t
        send-mail-function #'smtpmail-send-it
        message-sendmail-extra-arguments '("--read-envelope-from")
        mu4e-compose-switch nil
        mail-user-agent 'mu4e-user-agent
        mu4e-change-filenames-when-moving t
        mu4e-search-include-related nil
        mu4e-sent-messages-behavior 'delete
        mu4e-search-skip-duplicates nil ;; t
        mu4e-attachment-dir  "~/Downloads"
        mu4e-get-mail-command "mbsync -a"
        mu4e-update-interval 60

        ;; debugging stuff
        ;; mu4e-alert-interesting-mail-query "flag:unread AND NOT flag:trashed AND NOT maildir:/Inbox/" ; to prevent duplicated unread mail count

        mu4e-hide-index-messages t
        mu4e-compose-format-flowed t
        use-hard-newlines -1
        message-kill-buffer-on-exit t
        mu4e-compose--org-msg-toggle-next nil ; default to plaintext emails
        message-sendmail-f-is-evil t
        message-send-mail-function #'message-send-mail-with-sendmail
        mu4e-bookmarks '(("maildir:/fri/Inbox" "Inbox" ?i)
                         ("flag:unread AND NOT flag:trashed" "Unread messages" ?u)
                         ("flag:attach" "Has attachment" ?a)
                         ("date:today..now" "Today's messages" ?t)
                         ("date:7d..now" "Last 7 days" ?w)
                         ("date:1m..now" "Last month" ?m)))
  (set-email-account! "FRI"
                      '((mu4e-sent-folder       . "/fri/Sent Items")
                        (mu4e-drafts-folder     . "/fri/Drafts")
                        (mu4e-trash-folder      . "/fri/Deleted Items")
                        (mu4e-refile-folder     . "/fri/Archive")
                        (smtpmail-smtp-user     . "david.jelenc@fri.uni-lj.si"))
                      t)
  ;; (set-email-account! "Gmail"
  ;;                     '((mu4e-sent-folder       . "/gmail/Sent Mail")
  ;;                       (mu4e-drafts-folder     . "/gmail/Drafts")
  ;;                       (mu4e-trash-folder      . "/gmail/Trash")
  ;;                       (mu4e-refile-folder     . "/gmail/All Mail")
  ;;                       (smtpmail-smtp-user     . "djelenc.fri@gmail.com"))
  ;;                     t)

  ;; finds duplicate emails
  ;; https://emacs.stackexchange.com/questions/435/how-do-i-delete-duplicate-messages-in-mu4e
  (defvar *my-mu4e-headers-bol-positions* nil)
  (defun my-mu4e-headers-bol-positions ()
    "Obtain a list of beginning of line positions for *mu4e-headers*.

`*my-mu4e-headers-bol-positions*' is defined globally, as trying to use
let binding and using add-to-list was unsuccessful."
    ;; list-bol is nil, equivalent to an empty list.
    (with-current-buffer (mu4e-get-headers-buffer)
      (setq *my-mu4e-headers-bol-positions* nil)
      (save-excursion
        (goto-char (point-min))
        (while (search-forward mu4e~headers-docid-pre nil t)
          (add-to-list '*my-mu4e-headers-bol-positions* (line-beginning-position))
          ;; Need to move to the end of the line to look for the next line
          (end-of-line))
        (reverse *my-mu4e-headers-bol-positions*))))
  ;;
  (defun my-mu4e-headers-sexps-with-bol ()
    "Obtain the message s-expressions for the messages in *mu4e-headers* and extend with bol."
    (let ((list-bol (my-mu4e-headers-bol-positions)))
      (when list-bol
        (with-current-buffer (mu4e-get-headers-buffer)
          (seq-map (lambda (bol)
                     (let ((msg (get-text-property bol 'msg)))
                       (plist-put msg :bol bol)))
                   list-bol)))))
  ;;
  (defun my-mu4e-headers-sexps-with-bol-dups ()
    "Obtain the sexps for the messages in *mu4e-headers* with duplicated message-id."
    ;; https://emacs.stackexchange.com/questions/31448/report-duplicates-in-a-list
    (thread-last (my-mu4e-headers-sexps-with-bol)
                 ;; Group by :message-id and :flags (to avoid marking messaged handled differently).
                 (seq-group-by (lambda (sexp) (list (plist-get sexp :message-id)
                                                    (plist-get sexp :flags))))
                 (seq-filter (lambda (al) (> (length al) 2))))
    ;;
    (defun my-mu4e-headers-bol-dups ()
      "Obtain the beginning of line positions for duplicated messages in *mu4e-headers*.

The beginning of line position for the first of each duplicated messages set is retained."
      (thread-last (my-mu4e-headers-sexps-with-bol-dups)
                   ;; First of each duplicated messages set.
                   (seq-map (lambda (al) (cadr al)))
                   (seq-map (lambda (sexp) (plist-get sexp :bol)))
                   (seq-sort #'<)))
    ;;
    (defun my-mu4e-header-mark-duplicated ()
      "Mark the first of each duplicate messages set in *mu4e-headers* for an action."
      (interactive)
      (save-excursion
        (mapc
         (lambda (bol)
           (goto-char bol)
           (mu4e-headers-mark-for-something))
         (my-mu4e-headers-bol-dups)))))
  )
#+end_src
* Org-caldav sync
For syncing calendars with Google
#+begin_src emacs-lisp
(setq org-caldav-url "https://cloud.lem.im/remote.php/dav/calendars/david" ;; the base address of your CalDAV server
      org-caldav-calendar-id "orgmode" ;; the calendar-id of your new calendar:
      org-caldav-inbox "~/nextcloud/org/tickler.org" ;; org filename where new entries from the calendar should be stored.
      org-caldav-files '( ;; list of org files for sync (without org-caldav-inbox)
                         )
      org-icalendar-timezone "Europe/Ljubljana"
      org-caldav-save-directory "~/nextcloud/org/sync-cal"
      org-icalendar-alarm-time 15
      org-icalendar-use-deadline '(event-if-not-todo todo-due event-if-todo)
      org-icalendar-use-scheduled '(event-if-not-todo todo-start event-if-todo))
#+end_src
* Org-Super-Agenda
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :after org-agenda
  :init
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-include-deadlines t
        org-agenda-block-separator nil
        org-agenda-compact-blocks t
        org-agenda-start-day nil
        org-super-agenda-header-map nil
        org-agenda-span 7
        org-agenda-start-on-weekday nil
        ;; determines how tasks are prefixed in the agenda and todo views
        org-agenda-prefix-format '((agenda  . "  %?-12t% s")
                                   (todo  . "  "))
        org-agenda-custom-commands '((" " "Work view"
                                      ((agenda "" ((org-agenda-overriding-header "")
                                                   (org-agenda-files '("~/nextcloud/org/")) ;; all on calendar
                                                   (org-super-agenda-groups
                                                    '(
                                                      (:name none
                                                       :time-grid t
                                                       :not (:deadline future)
                                                       :order 0)
                                                      (:name "Upcoming"
                                                       :deadline future
                                                       :order 1)
                                                      (:discard (:anything))
                                                      ))))
                                       (alltodo "" ((org-agenda-overriding-header "")
                                                    (org-agenda-files '("~/nextcloud/org/refile.org"
                                                                        "~/nextcloud/org/mobile-refile.org"
                                                                        "~/nextcloud/org/active.org"))
                                                    (org-super-agenda-groups
                                                     '((:discard (:tag "private"))
                                                       (:name "Waiting"
                                                        :and (:todo "WAITING"
                                                              :not (:scheduled t :deadline t))
                                                        :order 3)
                                                       (:name "To refile"
                                                        :file-path ".*refile\\.org"
                                                        :order 1)
                                                       (:discard (:not (:todo "NEXT")))
                                                       (:discard (:file-path "tickler\\.org"))
                                                       (:discard (:scheduled t :deadline t))
                                                       (:auto-map (lambda (item) ;; name each project by its top-level heading
                                                                    (re-search-backward "^\* " nil t)
                                                                    (org-get-heading t t t t))
                                                        :order 2)
                                                       ))))))
                                     ("f" "Private view"
                                      ((agenda "" ((org-agenda-overriding-header "")
                                                   (org-agenda-files '("~/nextcloud/org/")) ;; all on calendar
                                                   (org-super-agenda-groups
                                                    '(
                                                      (:name none
                                                       :time-grid t
                                                       :not (:deadline future)
                                                       :order 0)
                                                      (:name "Upcoming"
                                                       :deadline future
                                                       :order 1)
                                                      (:discard (:anything))
                                                      ))))
                                       (alltodo "" ((org-agenda-overriding-header "")
                                                    (org-agenda-files '("~/nextcloud/org/refile.org"
                                                                        "~/nextcloud/org/mobile-refile.org"
                                                                        "~/nextcloud/org/zasebno.org"))
                                                    (org-super-agenda-groups
                                                     '((:discard (:tag "work"))
                                                       (:name "Waiting"
                                                        :and (:todo "WAITING"
                                                              :not (:scheduled t :deadline t))
                                                        :order 3)
                                                       (:name "To refile"
                                                        :file-path ".*refile\\.org"
                                                        :order 1)
                                                       (:discard (:not (:todo "NEXT")))
                                                       (:discard (:file-path "tickler\\.org"))
                                                       (:discard (:scheduled t :deadline t))
                                                       (:auto-map (lambda (item) ;; name each project by its top-level heading
                                                                    (re-search-backward "^\* " nil t)
                                                                    (org-get-heading t t t t))
                                                        :order 2)
                                                       ))))))
                                     ("r" "Reka view"
                                      ((agenda "" ((org-agenda-overriding-header "")
                                                   (org-agenda-files '("~/nextcloud/org/")) ;; all on calendar
                                                   (org-super-agenda-groups
                                                    '(
                                                      (:name none
                                                       :time-grid t
                                                       :not (:deadline future)
                                                       :order 0)
                                                      (:name "Upcoming"
                                                       :deadline future
                                                       :order 1)
                                                      (:discard (:anything))
                                                      ))))
                                       (alltodo "" ((org-agenda-overriding-header "")
                                                    (org-agenda-files '("~/nextcloud/org/refile.org"
                                                                        "~/nextcloud/org/mobile-refile.org"
                                                                        "~/nextcloud/org/reka.org"))
                                                    (org-super-agenda-groups
                                                     '(;(:discard (:tag "work"))
                                                       (:name "Waiting"
                                                        :and (:todo "WAITING"
                                                              :not (:scheduled t :deadline t))
                                                        :order 3)
                                                       (:name "To refile"
                                                        :file-path ".*refile\\.org"
                                                        :order 1)
                                                       (:discard (:not (:todo "NEXT")))
                                                       (:discard (:file-path "tickler\\.org"))
                                                       (:discard (:scheduled t :deadline t))
                                                       (:auto-map (lambda (item) ;; name each project by its top-level heading
                                                                    (re-search-backward "^\* " nil t)
                                                                    (org-get-heading t t t t))
                                                        :order 2)
                                                       ))))))
                                     ("s" "Stuck Projects"
                                      ((org-ql-block '(and (not (done))
                                                           (not "NEXT")
                                                           (path "active" "zasebno" "reka")
                                                           (level 1)
                                                           (not (descendants (todo "NEXT")))
                                                           (not (descendants (scheduled))))
                                                     ((org-ql-block-header "Stuck Projects")))))
                                     ("w" "Waiting-for list"
                                      ((alltodo "" ((org-agenda-overriding-header "")
                                                    (org-agenda-files '("~/nextcloud/org/refile.org"
                                                                        "~/nextcloud/org/zasebno.org"
                                                                        "~/nextcloud/org/reka.org"
                                                                        "~/nextcloud/org/inactive.org"
                                                                        "~/nextcloud/org/someday.org"
                                                                        "~/nextcloud/org/active.org"))
                                                    (org-super-agenda-groups
                                                     '((:discard (:not (:todo "WAITING")))
                                                       (:auto-map (lambda (item) ;; name each project by its top-level heading
                                                                    (re-search-backward "^\* " nil t)
                                                                    (org-get-heading t t t t))
                                                        :order 0)
                                                       ))))))
                                     )
        )
  :config
  (org-super-agenda-mode))
#+end_src
* Org-Download
Save images into =./images= relative to the Org file
#+begin_src emacs-lisp
(use-package! org-download
  :after org
  :init
  (setq org-download-method 'directory
        org-download-image-dir "images"
        org-download-heading-lvl nil
        org-download-link-format "[[file:%s]]"
        org-download-abbreviate-filename-function #'file-relative-name)

  :config
  ;; Region screenshot: slurp (select) + grim (capture) → save into images/
  (when (and (getenv "WAYLAND_DISPLAY")
             (executable-find "grim")
             (executable-find "slurp"))
    (setq org-download-screenshot-method "grim -g \"$(slurp)\" %s"))

  ;; Paste from Wayland clipboard → save into images/
  (when (executable-find "wl-paste")
    (defun dj/org-download-wl-paste ()
      "Paste an image from Wayland clipboard and save it into ./images."
      (interactive)
      (let ((tmp (make-temp-file "org-dl-" nil ".png")))
        (if (= 0 (call-process "/bin/sh" nil nil nil "-c"
                               (format "wl-paste --type image/png > %s"
                                       (shell-quote-argument tmp))))
            (org-download-image tmp)
          (user-error "No image/png in Wayland clipboard")))))
  )
#+end_src
* Org-roam and citations
In part inspired:
- https://jethrokuan.github.io/org-roam-guide
** org-roam
#+begin_src emacs-lisp
(use-package! org-roam
  :custom
  (org-roam-directory (file-truename "~/nextcloud/roam"))
  ;; (org-roam-dailies-directory "daily/")
  (org-roam-db-location (file-truename "~/Documents/roam.db"))
  (org-roam-db-node-include-function (lambda () (not (member "ATTACH" (org-get-tags))))) ; exclude all id's as nodes that have the ATTACH tag
  :config
  (org-roam-db-autosync-mode)

  (setq org-roam-capture-templates
        '(("m" "main" plain
           "%?"
           :if-new (file+head "main/${slug}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)
          ("r" "reference" plain "%?"
           :if-new (file+head "reference/${citar-citekey}.org"
                              "#+title: %(dj/citar-zettel-title)\n")
           :immediate-finish t :unnarrowed t)
          ("a" "article" plain "%?"
           :if-new
           (file+head "articles/${title}.org" "#+title: ${title}\n#+filetags: :article:\n")
           :immediate-finish t
           :unnarrowed t)))
  )
#+end_src
** citar and citar-org-roam
- With =citar-open= brings up the entire bibliography list;
- With =RET= select an entry;
- And an entry in ROAM is generated with =author-year-title= format and a link to the file.

#+begin_src emacs-lisp
(defconst dj/bib '("/home/david/Zotero/biblio.bib"))
(setq! org-cite-global-bibliography dj/bib
       citar-bibliography           dj/bib
       bibtex-completion-bibliography dj/bib
       bibtex-completion-pdf-field    "file")

(with-eval-after-load 'org-roam-bibtex
  (require 'bibtex-completion)
  (bibtex-completion-init))


(use-package! citar
  :after org
  :init
  (setq citar-bibliography dj/bib)
  :config
  (setq org-cite-insert-processor   'citar
        org-cite-follow-processor   'citar
        org-cite-activate-processor 'citar))

(use-package! citar-org-roam
  :after (citar org-roam)
  :config
  (citar-org-roam-mode 1)

  (require 'subr-x)   ;; string-trim, string-empty-p, string-join

  ;; Helper: get current citekey during org-roam capture (works with citar-org-roam)
  (defun dj/citar--current-citekey ()
    (or (and (boundp 'org-roam-capture--info)
             (plist-get org-roam-capture--info :citar-citekey))
        (and (boundp 'org-roam-capture--info)
             (plist-get org-roam-capture--info :citekey))
        (and (boundp 'citar-org-roam-citekey) citar-org-roam-citekey)))

  (defun dj/citar--split-authors (s)
    (when (and (stringp s) (not (string-empty-p s)))
      (let ((case-fold-search t)) ;; match "And" too, just in case
        (mapcar #'string-trim
                (split-string s "\\s-+and\\s-+" t)))))


  (defun dj/citar--family (person)
    (if (string-match-p "," person)
        (car (split-string person "\\s*,\\s*" t))          ; "Last, First" → "Last"
      (car (last (split-string person "\\s+" t)))))        ; "First Middle Last" → "Last"

  (defun dj/citar--year (entry)
    (let ((y (or (and (fboundp 'citar-get-value)  (citar-get-value 'year entry))
                 (and (fboundp 'citar-get-value)  (citar-get-value 'date entry))
                 (and (fboundp 'citar--get-value) (citar--get-value entry "year"))
                 (and (fboundp 'citar--get-value) (citar--get-value entry "date")))))
      (and y (string-match "\\([12][0-9][0-9][0-9]\\)" y) (match-string 1 y))))

  (defun dj/citar-zettel-title ()
    "Author (year): Title  OR  Author et al. (year): Title"
    (let* ((key   (dj/citar--current-citekey))
           (entry (or (and (fboundp 'citar-get-entry)  (citar-get-entry key))
                      (and (fboundp 'citar--get-entry) (citar--get-entry key))
                      (user-error "No Citar entry for key: %s" key)))
           (authors-str (or (and (fboundp 'citar-get-value)  (citar-get-value 'author entry))
                            (and (fboundp 'citar--get-value) (citar--get-value entry "author"))
                            (and (fboundp 'citar-get-value)  (citar-get-value 'editor entry))
                            (and (fboundp 'citar--get-value) (citar--get-value entry "editor"))
                            ""))
           (authors (dj/citar--split-authors authors-str))
           (first   (if authors (dj/citar--family (car authors)) ""))
           (etal    (if (> (length authors) 1) " et al." ""))
           (year    (or (dj/citar--year entry) "n.d."))
           (title   (or (and (fboundp 'citar-get-value)  (citar-get-value 'title entry))
                        (and (fboundp 'citar--get-value) (citar--get-value entry "title"))
                        key)))
      (string-trim (format "%s%s (%s): %s" first etal year title))))


  ;; Find first attached file for KEY (via Citar), else nil.
  (defun dj/citar--first-file (key)
    "Return first file path for KEY from Citar, across versions."
    (cond
     ((fboundp 'citar-get-files)
      ;; Prefer passing a list of keys; many versions return a hash-table/alist.
      (let ((res (citar-get-files (list key))))
        (cond
         ((hash-table-p res) (car (gethash key res)))
         ((and (listp res) (consp (car res))) (cadar res))   ; ((KEY (files...)) …)
         ((and (listp res) (stringp (car res))) (car res))   ; rare: plain list of paths
         (t nil))))
     ((fboundp 'citar-file--files)
      (let ((res (citar-file--files key)))
        (cond
         ((hash-table-p res) (car (gethash key res)))
         ((and (listp res) (stringp (car res))) (car res))
         ((and (listp res) (consp (car res))) (cadar res))
         (t nil))))
     (t nil)))

  ;; Make citar-org-roam use the "r" template from org-roam-capture-templates
  (setq citar-org-roam-capture-template-key "r"
        citar-org-roam-subdir "reference"
        citar-org-roam-note-title-template nil)
  )

(map! :map org-roam-bibtex-mode-map
      :desc "ORB note actions"
      :leader "m m b"
      #'orb-note-actions)
#+end_src
* Spelling
** Set default dictionary
#+begin_src emacs-lisp
(setq ispell-local-dictionary "sl"
      ispell-dictionary "sl")
#+end_src
** Disable spell check by default in text buffers
#+begin_src emacs-lisp
(after! org (add-hook! org-mode :append (flyspell-mode -1)))
#+end_src
** Save abbreviations to local dictionary
#+begin_src emacs-lisp
(setq save-abbrevs 'silently)
(setq-default abbrev-mode t)
#+end_src
** Bring up spell checker with =C-x C-i=
#+begin_src emacs-lisp
(map! "C-x C-i" 'endless/flyspell-word-then-abbrev)

(defun endless/flyspell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global."
  (interactive "P")
  (save-excursion
    (if (flyspell-goto-previous-word (point))
        (let ((bef (downcase (or (thing-at-point 'word)
                                 "")))
              aft)
          (call-interactively 'ispell-word)
          (setq aft (downcase
                     (or (thing-at-point 'word) "")))
          (unless (or (string= aft bef)
                      (string= aft "")
                      (string= bef ""))
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob"))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)))
      (message "Cannot find a misspelled word"))))
(defun flyspell-goto-previous-word (position)
  "Go to the first misspelled word that occurs before point.
But don't look beyond what's visible on the screen."
  (interactive "d")
  (let ((top (window-start))
        (bot (window-end)))
    (save-restriction
      (narrow-to-region top bot)
      (overlay-recenter (point))
      (add-hook 'pre-command-hook
                (function flyspell-auto-correct-previous-hook) t t)
      (unless flyspell-auto-correct-previous-pos
        ;; only reset if a new overlay exists
        (setq flyspell-auto-correct-previous-pos nil)
        (let ((overlay-list (overlays-in (point-min) position))
              (new-overlay 'dummy-value))
          ;; search for previous (new) flyspell overlay
          (while (and new-overlay
                      (or (not (flyspell-overlay-p new-overlay))
                          ;; check if its face has changed
                          (not (eq (get-char-property
                                    (overlay-start new-overlay) 'face)
                                   'flyspell-incorrect))))
            (setq new-overlay (car-safe overlay-list))
            (setq overlay-list (cdr-safe overlay-list)))
          ;; if nothing new exits new-overlay should be nil
          (if new-overlay ;; the length of the word may change so go to the start
              (setq flyspell-auto-correct-previous-pos
                    (overlay-start new-overlay)))))
      (if (not flyspell-auto-correct-previous-pos)
          nil
        (goto-char flyspell-auto-correct-previous-pos)
        t)))
  )
#+end_src
** Switch language with =leader t j=
#+begin_src emacs-lisp
(map!
 :desc "Toggle Slovene and English spelling" :leader "t j" (cmd! (toggle-ispell-language))
 )

(defun toggle-ispell-language ()
  "Toggle spelling language between Slovenian and English"
  (if (string= ispell-local-dictionary "english")
        (ispell-change-dictionary "sl")
    (ispell-change-dictionary "english"))
  )
#+end_src
* Reveal.js
#+begin_src emacs-lisp
(after! org
  (load-library "ox-reveal")
  (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
#+end_src
* Latex
When exporting ORG to LATEX, convert SVG images to PDF with Inkscape.
#+begin_src emacs-lisp
(after! org
  (setq org-latex-pdf-process
        '("latexmk -shell-escape -f -pdf -%latex -interaction=nonstopmode -output-directory=%o %f")
        )
  )

  ;; ("latexmk -f -pdf -%latex -interaction=nonstopmode -output-directory=%o %f")

#+end_src
* Gptel
ChatGPT, and others, in Emacs.
#+begin_src emacs-lisp
(use-package! gptel
  :config
  ;; Read the API key from a file and trim any trailing newline/whitespace
  (setq! gptel-api-key
         (string-trim
          (with-temp-buffer
            (insert-file-contents "/run/secrets/open_ai_test")
            (buffer-string)))))
#+end_src
* PDF tooling
** Auto-select newly created annotations
Usually the default, but ensure it
#+begin_src emacs-lisp
(setq pdf-annot-activate-created-annotations t)

(defun dj/pdf-annot-open-editor-after-add (&rest _ignore)
  "Open the annotation contents buffer right after creating an annotation."
  (when (and (boundp 'pdf-annot-activate-created-annotations)
             pdf-annot-activate-created-annotations)
    ;; The just-created annot is selected; open its contents buffer.
    (pdf-annot-edit-contents)))

(dolist (fn '(pdf-annot-add-highlight-markup-annotation
              pdf-annot-add-underline-markup-annotation
              pdf-annot-add-strikeout-markup-annotation
              pdf-annot-add-squiggly-markup-annotation
              pdf-annot-add-text-annotation))
  (advice-add fn :after #'dj/pdf-annot-open-editor-after-add))
#+end_src
** Backward compatibility fix for storing links to pages in PDFs
#+begin_src emacs-lisp
;; Emacs 30+: provide the old cl 'find-if' symbol via cl-lib
(require 'cl-lib)
(unless (fboundp 'find-if)
  (defalias 'find-if #'cl-find-if))

;; Org-pdftools compat for Emacs 30 (old cl.el symbols)
(with-eval-after-load 'org-pdftools
  (require 'cl-lib)
  (unless (fboundp 'find-if) (defalias 'find-if #'cl-find-if))
  (unless (fboundp 'getf)    (defalias 'getf    #'cl-getf)))
#+end_src
* Markdown paper authoring
Hand-crafted (and GPT-assisted) bits that allows writing paper in Markdown, referencing bibtex bibliography and cross-referencing images, tables, equations and sections.
** Citation helpers
Rely heavily on citar.
#+begin_src emacs-lisp
(require 'subr-x)

;; ---------- Markdown helpers ----------
(defun dj/md--yaml-front-matter-string ()
  "Return YAML front matter as a string, or nil if not present."
  (save-excursion
    (goto-char (point-min))
    (when (looking-at-p "^---\\s-*$")
      (forward-line 1)
      (let ((start (point)))
        (when (re-search-forward "^\\(---\\|\\.\\.\\.\\)\\s-*$" nil t)
          (buffer-substring-no-properties start (match-beginning 0)))))))

(defun dj/md--extract-bibs ()
  "Return list of .bib files from Markdown YAML `bibliography:` (scalar or [list])."
  (let ((yaml (dj/md--yaml-front-matter-string))
        files)
    (when yaml
      (with-temp-buffer
        (insert yaml)
        (goto-char (point-min))
        (when (re-search-forward "^bibliography:\\s-*\\(.+\\)$" nil t)
          (let ((rhs (string-trim (match-string 1))))
            (cond
             ;; Inline list: [a.bib, "b.bib"]
             ((and (>= (length rhs) 2)
                   (string-prefix-p "[" rhs)
                   (string-suffix-p "]" rhs))
              (dolist (p (split-string (substring rhs 1 -1) "," t "\\s-*"))
                (setq p (string-trim p "\"'"))
                (when (string-suffix-p ".bib" p) (push p files))))
             ;; Scalar: bibliography: refs.bib (optionally quoted)
             ((not (string-empty-p rhs))
              (setq rhs (string-trim rhs "\"'"))
              (when (string-suffix-p ".bib" rhs) (push rhs files)))))))
      (when files
        (setq files (nreverse files))
        (mapcar (lambda (f)
                  (expand-file-name f (or (and buffer-file-name (file-name-directory buffer-file-name))
                                          default-directory)))
                files)))))

;; ---------- Org helper ----------
(defun dj/org--extract-bibs ()
  "Return list of .bib files from Org `#+bibliography:` lines."
  (let (files)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^#\\+bibliography:\\s-*\\(.+\\)$" nil t)
        (dolist (p (split-string (match-string 1) "[ \t]+" t))
          (when (string-suffix-p ".bib" p)
            (push (expand-file-name p (or (and buffer-file-name (file-name-directory buffer-file-name))
                                          default-directory))
                  files)))))
    (nreverse files)))

;; ---------- Core setter ----------
(defun dj/set-buffer-bibliography ()
  "Detect local .bib files and set buffer-local `citar-bibliography`."
  (interactive)
  (require 'citar)
  (let* ((local (cond
                 ;; ((derived-mode-p 'org-mode)      (dj/org--extract-bibs))
                 ((derived-mode-p 'markdown-mode) (dj/md--extract-bibs))
                 (t nil)))
         (final (or local org-cite-global-bibliography)))
    (setq-local citar-bibliography final
                bibtex-completion-bibliography final)))

(defalias 'dj/reload-bibliography #'dj/set-buffer-bibliography)

;; ---------- Hooks ----------
(add-hook 'markdown-mode-hook #'dj/set-buffer-bibliography)
(add-hook 'after-save-hook
          (lambda ()
            (when (memq major-mode '(org-mode markdown-mode))
              (dj/set-buffer-bibliography))))


(defun dj/markdown-insert-pandoc-citation (&optional raw)
  "Pick refs via Citar and insert a Pandoc citation.
Default: insert [@key1; @key2].
With C-u (RAW), insert @key1; @key2 (no brackets)."
  (interactive "P")
  (require 'citar)
  (let* ((keys (citar-select-refs :multiple t))       ; pick one or many
         (body (mapconcat (lambda (k) (concat "@" k)) keys "; ")))
    (insert (if raw body (format "[%s]" body)))))

;; Keybindings: localleader @ in Markdown like Org's SPC m @
(after! markdown-mode
  (map! :map markdown-mode-map
        :localleader
        :desc "Insert bibliography"
        "@" #'dj/markdown-insert-pandoc-citation))
#+end_src
** Cross-references
Crossref label picker & inserter (Markdown)

#+begin_src emacs-lisp
(require 'subr-x)
(require 'seq)

(defun dj/pandoc-xref--collect ()
  "Return candidates of pandoc-crossref labels in current buffer.
Each candidate is (DISPLAY . KEY), where KEY is like \"fig:arch\"."
  (save-excursion
    (goto-char (point-min))
    (let (pairs)
      ;; Figures: ![Caption](...){#fig:arch}
      (while (re-search-forward "^!\\[\\([^]\n]*\\)\\][^\n]*{#\\(fig:[^} \t\n]+\\)[^}]*}" nil t)
        (push (cons (format "%s — Figure: %s" (match-string 2)
                            (string-trim (match-string 1)))
                    (match-string 2))
              pairs))
      ;; Tables: Table: Caption {#tbl:results}
      (goto-char (point-min))
      (while (re-search-forward "^Table:\\s-*\\([^{}\n]*?\\)\\s-*{#\\(tbl:[^} \t\n]+\\)}" nil t)
        (push (cons (format "%s — Table: %s" (match-string 2)
                            (string-trim (match-string 1)))
                    (match-string 2))
              pairs))
      ;; Sections: ## Title {#sec:label}
      (goto-char (point-min))
      (while (re-search-forward "^#+\\s-+\\([^{\n]*?\\)\\s-*{#\\(sec:[^} \t\n]+\\)}" nil t)
        (push (cons (format "%s — Section: %s" (match-string 2)
                            (string-trim (match-string 1)))
                    (match-string 2))
              pairs))
      ;; Equations: $$ ... $$ {#eq:label}
      (goto-char (point-min))
      (while (re-search-forward "{#\\(eq:[^} \t\n]+\\)}" nil t)
        (push (cons (format "%s — Equation" (match-string 1)) (match-string 1)) pairs))
      ;; Equations (LaTeX): \label{eq:label}
      (goto-char (point-min))
      (while (re-search-forward "\\\\label{\\(eq:[^} \t\n]+\\)}" nil t)
        (push (cons (format "%s — Equation" (match-string 1)) (match-string 1)) pairs))
      ;; Listings (if you use them): {#lst:label}
      (goto-char (point-min))
      (while (re-search-forward "{#\\(lst:[^} \t\n]+\\)}" nil t)
        (push (cons (format "%s — Listing" (match-string 1)) (match-string 1)) pairs))

      ;; Deduplicate by KEY, prefer first description we saw
      (let* ((seen (make-hash-table :test 'equal))
             out)
        (dolist (p pairs)
          (unless (gethash (cdr p) seen)
            (puthash (cdr p) t seen)
            (push (cons (car p) (cdr p)) out)))
        (sort out (lambda (a b) (string< (cdr a) (cdr b))))))))

(defun dj/insert-pandoc-xrefs (&optional raw)
  "Prompt for one or more xref labels and insert Pandoc refs.
Default inserts [@key1; @key2]. With C-u (RAW), insert @key1; @key2."
  (interactive "P")
  (let* ((items (dj/pandoc-xref--collect)))
    (unless items
      (user-error "No pandoc-crossref labels found in this buffer"))
    (let* ((choices (completing-read-multiple
                     "Insert reference(s): "
                     (mapcar #'car items) nil t))
           (keys (mapcar (lambda (disp) (cdr (assoc disp items))) choices))
           (body (mapconcat (lambda (k) (concat "@" k)) keys "; ")))
      (insert (if raw body (format "[%s]" body))))))

;; Filtered variants (figure/table/eq/section), handy on muscle memory:
(defun dj/insert-pandoc-xrefs-type (prefix &optional raw)
  "Like `dj/insert-pandoc-xrefs' but restricted to PREFIX, e.g. \"fig\"."
  (interactive "sType (fig/tbl/eq/sec/lst): \nP")
  (let* ((items (seq-filter (lambda (p) (string-prefix-p (concat prefix ":") (cdr p)))
                            (dj/pandoc-xref--collect))))
    (unless items (user-error "No %s labels found" prefix))
    (let* ((choices (completing-read-multiple
                     (format "Insert %s reference(s): " prefix)
                     (mapcar #'car items) nil t))
           (keys (mapcar (lambda (disp) (cdr (assoc disp items))) choices))
           (body (mapconcat (lambda (k) (concat "@" k)) keys "; ")))
      (insert (if raw body (format "[%s]" body))))))

(defun dj/insert-pandoc-fig-ref (&optional raw) (interactive "P") (dj/insert-pandoc-xrefs-type "fig" raw))
(defun dj/insert-pandoc-tbl-ref (&optional raw) (interactive "P") (dj/insert-pandoc-xrefs-type "tbl" raw))
(defun dj/insert-pandoc-eq-ref  (&optional raw) (interactive "P") (dj/insert-pandoc-xrefs-type "eq"  raw))
(defun dj/insert-pandoc-sec-ref (&optional raw) (interactive "P") (dj/insert-pandoc-xrefs-type "sec" raw))

;; Doom localleader bindings
(after! markdown-mode
  (map! :map markdown-mode-map
        :localleader
        :desc "Insert cross-reference"
        "r" #'dj/insert-pandoc-xrefs))
#+end_src
** ORG like =C-RET= behavior
Makes pressing =C-RET= do the same thing as in =org-mode=:
- In a list item (or its continuation lines): insert a sibling item below
  without splitting the current line.
- Else: insert a new heading *after the current section* (same level as the
  current heading). If not under any heading, insert a level-1 heading. Leaves point at the new heading.
#+begin_src emacs-lisp
(after! markdown-mode
  (require 'outline)

  ;; Am I in/under a list item?
  (defun dj/md-in-list-p ()
    (or (and (fboundp 'markdown-cur-list-item-bounds)
             (markdown-cur-list-item-bounds))
        (save-excursion
          (beginning-of-line)
          (looking-at "\\s-*\\([*+-]\\|[0-9]+[.)]\\)\\s-"))))

  ;; Return current ATX heading level (# count) or nil. Always move to BOL of heading.
  (defun dj/md-current-heading-level ()
    (save-excursion
      (when (outline-back-to-heading t)
        (when (looking-at "^\\(#+\\)\\s-")
          (length (match-string 1))))))

  ;; Insert ATX heading at POS with LEVEL hashes.
  ;; Return point *after* the inserted "#+space", ready for typing.
  (defun dj/md-insert-heading-at (pos level)
    (save-excursion
      (goto-char pos)
      (unless (bolp) (end-of-line) (newline))
      (unless (save-excursion (forward-line -1) (looking-at-p "^\\s-*$"))
        (newline))
      (insert (make-string (max 1 level) ?#) " ")
      (point)))

  (defun dj/markdown-c-return (&optional _arg)
    "Org-like C-RET in Markdown.

- In a list item (or its continuation lines): insert a sibling item below
  without splitting the current line.
- Else: insert a new heading *after the current section* (same level as the
  current heading). If not under any heading, insert a level-1 heading.

Leaves point at the new heading."
    (interactive "P")
    (if (dj/md-in-list-p)
        (progn
          (end-of-line)
          (call-interactively #'markdown-insert-list-item))
      (let* ((lvl (dj/md-current-heading-level))
             (dest
              (if lvl
                  (save-excursion
                    (outline-back-to-heading t)
                    (outline-end-of-subtree)
                    (dj/md-insert-heading-at (point) lvl))
                (save-excursion
                  (end-of-line)
                  (dj/md-insert-heading-at (point) 1)))))
        (goto-char dest))))

  (map! :map markdown-mode-map
        :n "C-RET"     #'dj/markdown-c-return
        :i "C-RET"     #'dj/markdown-c-return
        :v "C-RET"     #'dj/markdown-c-return
        :n [C-return]  #'dj/markdown-c-return
        :i [C-return]  #'dj/markdown-c-return
        :v [C-return]  #'dj/markdown-c-return))
#+end_src
** Export via =Makefile=
#+begin_src emacs-lisp
;;; Export current Markdown file via Makefile targets (pdf/html/tex)
(after! markdown-mode
  (require 'compile)

  (defgroup dj/paper nil
    "Pandoc/pandoc-crossref Makefile export helpers."
    :group 'tools)

  (defcustom dj/paper-open-after-build t
    "Open the produced artifact if the build succeeds."
    :type 'boolean :group 'dj/paper)

  ;; If non-nil: don't show the compilation buffer unless there are errors.
  (defcustom dj/paper-quiet-success t
    "Hide compilation output on success; show only on errors."
    :type 'boolean :group 'dj/paper)

  (defun dj/paper--finish (buf status)
    "On success, (optionally) open the artifact; on failure, show BUF."
    (let ((success (string-match-p "\\`finished" status)))
      (if success
          (progn
            (when dj/paper-open-after-build
              (with-current-buffer buf
                (when (and (boundp 'dj/paper--outfile)
                           dj/paper--outfile
                           (file-exists-p dj/paper--outfile))
                  (dj/paper--open-file dj/paper--outfile))))
            ;; Kill/bury the compilation buffer on success.
            (when (buffer-live-p buf) (kill-buffer buf)))
        ;; Failure: surface the buffer so you can see the errors.
        (display-buffer buf))))

  ;; Install a single global finish hook.
  (add-hook 'compilation-finish-functions #'dj/paper--finish)

  (defun dj/paper--find-root ()
    "Find directory that contains a Makefile above current buffer."
    (or (and buffer-file-name
             (locate-dominating-file buffer-file-name "Makefile"))
        (user-error "No Makefile found above %s" (or buffer-file-name default-directory))))

  (defun dj/paper--basename ()
    "Return file basename without extension for current buffer."
    (or (and buffer-file-name (file-name-base buffer-file-name))
        (user-error "Buffer is not visiting a file")))

  (defun dj/paper--output-path (root base target)
    "Compute expected output path, given ROOT, BASE and TARGET."
    (expand-file-name
     (pcase target
       ("pdf"  (format "%s.pdf"  base))
       ("html" (format "%s.html" base))
       ("tex"  (format "%s.tex"  base))
       (_ "")) ;; clean or unknown: nothing to open
     root))

  ;; Open a file with the OS default application (async).
(defun dj/system-open (file)
  "Open FILE with the system default app."
  (when (and file (file-exists-p file))
    (pcase system-type
      ('darwin
       (start-process "open" nil "open" file))
      ('windows-nt
       ;; Ensure backslashes for w32-shell-execute.
       (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" file t t)))
      (_
       ;; Linux/BSD: prefer xdg-open; fall back to gio open/gnome-open/kde-open
       (let* ((prog (or (executable-find "xdg-open")
                        (executable-find "gio")
                        (executable-find "gnome-open")
                        (executable-find "kde-open")))
              (args (cond
                     ((null prog) nil)
                     ((string-suffix-p "/gio" prog) (list "open" file))
                     (t (list file)))))
         (if prog
             (apply #'start-process "sys-open" nil prog args)
           (browse-url-of-file file)))))))

(defun dj/paper--open-file (path)
  "Open PATH sensibly: HTML in browser, PDF via system viewer, others via `org-open-file`."
  (when (and path (file-exists-p path))
    (let ((ext (downcase (or (file-name-extension path) ""))))
      (cond
       ((string= ext "html") (browse-url-of-file path))
       ((string= ext "pdf")  (dj/system-open path))
       (t                    (org-open-file path))))))

  (defun dj/paper--make (target)
    "Run `make TARGET PAPER=<basename>` at nearest Makefile root.
Hides the compilation buffer immediately; only shows it on errors."
    (interactive)
    (let* ((root (dj/paper--find-root))
           (base (dj/paper--basename))
           (default-directory root)
           (cmd  (format "make %s PAPER=%s"
                         (shell-quote-argument target)
                         (shell-quote-argument base)))
           (outfile (dj/paper--output-path root base target)))
      (save-some-buffers t)
      (message "Building %s with PAPER=%s in %s" target base root)
      (let ((buf (compile cmd)))
        ;; Stash expected artifact path on the compilation buffer for the finish hook.
        (when (bufferp buf)
          (with-current-buffer buf
            (setq-local dj/paper--outfile
                        (and (not (string-empty-p outfile)) outfile))))
        ;; Quiet mode: close the window immediately; we’ll re-show on error.
        (when (and dj/paper-quiet-success (bufferp buf))
          (when-let ((win (get-buffer-window buf)))
            (delete-window win))))
      ;; Return non-nil to placate callers.
      t))

  ;; Public entry points
  (defun dj/paper-make-pdf  () (interactive) (dj/paper--make "pdf"))
  (defun dj/paper-make-html () (interactive) (dj/paper--make "html"))
  (defun dj/paper-make-tex  () (interactive) (dj/paper--make "tex"))
  (defun dj/paper-make-clean() (interactive) (dj/paper--make "clean"))

  ;; Optional: a small transient for discoverability (if available)
  (when (require 'transient nil t)
    (transient-define-prefix dj/paper-export-dispatch ()
      "Pandoc Makefile export"
      [["Targets"
        ("p" "PDF"  dj/paper-make-pdf)
        ("h" "HTML" dj/paper-make-html)
        ("t" "TeX"  dj/paper-make-tex)
        ("c" "Clean" dj/paper-make-clean)]
       ["Options"
        ("o" "Toggle open-after-build"
         (lambda ()
           (interactive)
           (setq dj/paper-open-after-build (not dj/paper-open-after-build))
           (message "Open after build: %s" dj/paper-open-after-build)))]]))

  ;; Doom localleader bindings (Markdown)
  (map! :map markdown-mode-map
        :localleader
        (:prefix ("e" . "export (Make)")
         :desc "PDF (make pdf)"  "p" #'dj/paper-make-pdf
         :desc "HTML (make html)" "h" #'dj/paper-make-html
         :desc "TeX (make tex)"   "t" #'dj/paper-make-tex
         :desc "Clean"            "c" #'dj/paper-make-clean
         :desc "Dispatch (if available)" "e" (cmd! (call-interactively 'dj/paper-export-dispatch)))))
#+end_src
